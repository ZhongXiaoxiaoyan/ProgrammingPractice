//剑指offer：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））
//
//分析：使用双栈实现。一个数据栈data, 一个最小栈min.数据栈存正常入栈的元素，最小栈永远存数据栈中当前最小值。具体是依靠以下规则来实现的。入栈时无论如何先给数据栈入栈，而此时看入栈的元素与最小栈栈顶元素的大小，如果该元素小于等于最小栈栈顶元素，就将该元素也给最小栈入栈，否则说明要入栈的元素大于当前最小栈的栈顶元素，则不用更新当前最小栈栈顶元素，因此为了保持与数据栈的元素个数相等，最小栈将其栈顶元素再入一次，表明此时最小元素还是原来的数据；出栈时两个栈同时出，因为要保持数据个数一致，当要找当前最小元素时，直接从最小栈的栈顶弹出元素即可。



stack<int> Mmin;//最小栈
stack<int> data;//数据栈

//入栈
void push(int value) {
	data.push(value);//无论怎样，数据栈首先入栈

	//当最小栈为空，或者要入的元素<最小栈栈顶，则给最小栈入栈
	if (Mmin.empty() || value <= Mmin.top())
	{
		Mmin.push(value);
	}
	else//大于等于就入最小栈原来栈顶元素
	{
		Mmin.push(Mmin.top());
	}
}
//出栈
void pop() {
	//保证两个栈都不为空
	if (!data.empty() && !Mmin.empty())
	{
		//两个栈都出栈
		data.pop();
		Mmin.pop();
	}
}
//最小元素(直接就是最小栈的栈顶)
int top() {
	return data.top();
}
int min() {
	return Mmin.top();
}