//题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1, 2, 3, 4, 5是某栈的压入顺序，序列4, 5, 3, 2, 1是该压栈序列对应的一个弹出序列，但4, 3, 5, 1, 2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
//
//分析：借助一个栈，根据给定的入栈序、出栈序模拟它的过程，看看能不能对的上。具体规则是借助一个栈，拿着它的入栈序进行入栈，每入一次就看看栈顶元素是不是和它的出栈序一样，一样的话我们也出栈，这里需要循环判断，即出栈完继续看栈顶元素和它的下一个出栈序一样不，一样继续出栈，不一样继续按照它的入栈序入栈，直到入栈序完，此时如果我们的辅助栈如果是空的话，说明它给定的入栈序与出栈序可以匹配，因为每一个入栈元素都会根据出栈序全部出栈，否则说明不匹配。


bool IsPopOrder(vector<int>& pushV, vector<int>& popV) {
	stack<int> s;
	int j = 0;
	for (int i = 0; i<pushV.size(); i++)
	{
		s.push(pushV[i]);//将入栈序元素入栈
		while (!s.empty() && s.top() == popV[j])//栈顶元素等于出栈序，则出栈
		{
			s.pop();
			j++;//出栈序下标往后移动一下
		}
	}
	return s.empty();
}